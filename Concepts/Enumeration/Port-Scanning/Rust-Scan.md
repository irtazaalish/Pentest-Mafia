# About Rust Scan

Rustscan is a modern day port scanner which is faster and supports extensible scripting language allowing users to write scripts in python and more.

## Tools

> [RustScan's GitHub repository] (<https://github.com/RustScan/RustScan>)

## Installation

Installing RustScan is very easy.

If you use Mac OS, Arch, Docker, Nix OS or any other operating system than Debian more install instructions can be found on the repository.

> [here] (<https://github.com/RustScan/RustScan/wiki/Installation-Guide>)

1. goto rustscan [repo] (<https://github.com/RustScan/RustScan/releases>)

2. Download the .deb file for Kali Linux.
[rustscan_1.8.0_amd64.deb] (<https://github.com/RustScan/RustScan/releases/download/1.8.0/rustscan_1.8.0_amd64.deb>)

3. In terminal type:-  dpkg -i (file name)  

4. Try running rustscan in terminal.

## Speed

Rustscan is fast:
And it is fast because of the following reasons:

1. Low level kernal networking
2. It is written in rust which is a faster language
3. Asynchronous scanning. Multi-threading is slow due to the context switching cost. Async is fast.

## Extensible

RustScan is extensible by the RustScan Scripting Engine. This allows you to write a script which runs after the scan has completed, taking inputs of open ports and their respective IPs.

RSE supports these languages:

1. Python
2. Shell
3. Perl
4. Any program which is a binary and in $PATH

### Scripting Engine Arguments

RustScan's scripting engine can be altered using the "--scripts" argument.

There are 3 possible arguments:

1. None (don't run any scripts)
2. Custom (run all scripts in the scripts folder)
3. Default (runs Nmap script, or whatever script is in the config file. Default does not need to be enabled, it is on by default.)

### Python Custom Scripts

To execute a custom script, we need a rustscan_scripts.toml file located at $HOME/.rustscan_scripts.toml.

The script file should look like:

```py
# Test/Example ScriptConfig file

# Tags to filter on scripts. Only scripts containing all these tags will run.
tags = ["core_approved", "example"]

# If it's present then only those scripts will run which has a tag ports = "80". Not yet implemented.
#
# ex.:
# ports = ["80"]
# ports = ["80","81","8080"]
ports = ["80"]

# Only this developer(s) scripts to run. Not yet implemented.
developer = ["example"]
```

Let's walk through this.

Firstly, for reference, this is a basic Python script.

```py

#!/usr/bin/python3
#tags = ["core_approved", "example",]
#developer = [ "example", "https://example.org" ]
#trigger_port = "80"
#call_format = "python3 {{script}} {{ip}} {{port}}"

# Scriptfile parser stops at the first blank line with parsing.
# This script will run itself as an argument with the system installed python interpreter, only scanning port 80.
# Unused filed: ports_separator = ","

import sys

print('Python script ran with arguments', str(sys.argv))

```

Note: the metadata of scripts is stored as comments. The first line is always a shebang.

### Tags

Tags are categories of scripts. For example, we may have these categories:

1. HTTP
2. SSH
3. Tomcat

And only wish to run scripts that match these categories. Our config file will only execute the scripts with matching categories.

### Developer

This tag issues who the developer of the script is.

### Trigger Point

This tag states at what port should the script trigger? For HTTP it would be "80". For HTTP and HTTPS it would be "80, 443"

### Call Format

RustScan uses a templating library called text_placeholder.

This allows us to enclose variables in {{variable}} doubly curly braces. RustScan supports 3 variables:

1. The script name
2. The IP address
3. The port(s)

```py
#call_format = "python3 {{script}} {{ip}} {{port}}"
```

### The Code itself

Now everything after this metadata is the code itself.

The script will receive arguments via sys.argv in the format specified in the call_format variable.

Now with this data, we run the script, doing whatever we please!

### Running Other Tools with RustScan

Any tool installed in the system (like Nmap, GoBuster, etc) can be run with RustScan.

We do this by default with Nmap.

To execute another program, create a shell script which calls that program. So to call Nmap, create a shell script with our RustScan Scripting Engine and then for the function:

```py
nmap -vvv -p {{port}} {{ip}}
```

You can replace this with GoBuster or any program at all. So long as the program is installed and reachable in the environment $PATH

## Adaptive

RustScan is adaptive. That means it changes how it works to better suit its environment. We call this the "adaptive learning" feature set.

Some of these features included (or are being worked on) are:

- Adaptive Outbound SYN timing to optimize the speed of scanning

While RustScan scans the target, it learns how it reacts, How fast is it to scan? Does it respond quickly? How far away?

By using this data RustScan moulds itself so it is the fastest scanner for any target.

- Custom Top Ports

You may be familiar with the top ports feature of other scanners. It'll let you scan the top 1000 ports on the internet.

But, the top 1000 ports on the internet are not often the top 1000 ports you might come across. Corporate networks may have unusual ports open, capture the flag events may have unusual ports. As an example, port 31137 is used a lot in CTFs because "l33t".

This port is not in any top 1000 ports list.

RustScan learns what the most commonly open ports are for you and adapts itself.

- Operating System Adaption

Your computer is not the same as my computer. So why run the same scan settings? Mac OS devices have an open file limit of around 250. That means they can only make 250 connections at any given time.

Kali Linux has around 90,000 open files.

If we built this for Kali Linux, it would break on a Mac which does not support that many open files.

RustScan learns about your operating system and adapts itself to better suit you and your computer, as well as the networks it is scanning.

- Configuration File

All of this information is stored in a configuration file.

## Scanning Guide

The tool is really amazing in terms of scanning. It can scan all the ports really fast and then pipe the output to the Nmap.

Basic format for RustScan is:

```bash
rustscan -r ports -a  <Target-ip> -- <nmap cmds>
```

Here's a full list of things you can do.

### Multiple IP Scanning

You can scan multiple IPs using a comma-separated list like so:

```bash
rustscan -a 127.0.0.1,0.0.0.0
```

### Host Scanning

RustScan can also scan hosts, like so:

```bash
rustscan -a www.google.com, 127.0.0.1
Open 216.58.210.36:1
Open 216.58.210.36:80
Open 216.58.210.36:443
Open 127.0.0.1:53
Open 127.0.0.1:631
```

### CIDR support

RustScan supports CIDR:

```bash
rustscan -a 192.168.0.0/30
```

### Hosts file as input

The file is a new line separated list of IPs / Hosts to scan:

hosts.txt

```bash
192.168.0.1
192.168.0.2
google.com
192.168.0.0/30
127.0.0.1
```

The argument is:

```bash
rustscan -a 'hosts.txt'
```

### Individual Port Scanning

RustScan can scan individual ports, like so:

```bash
rustscan -a 127.0.0.1 -p 53
53
```

### Multiple selected port scanning

You can input a comma-separated list of ports to scan:

```bash
rustscan -a 127.0.0.1 -p 53,80,121,65535
53
```

### Ranges of ports

To scan a range of ports:

To run:

```bash
rustscan -a 127.0.0.1 --range 1-1000    
53,631
```

### Adjusting the Nmap arguments

RustScan, at the moment, runs Nmap by default.

You can adjust the arguments like so:

```bash
rustscan -a 127.0.0.1 -- -A -sC
```

To run:

```bash
nmap -Pn -vvv -p $PORTS -A -sC 127.0.0.1
```

### Random Port Ordering

If you want to scan ports in a random order (which will help with not setting off firewalls) run RustScan like this:

```bash
rustscan -a 127.0.0.1 --range 1-1000 --scan-order "Random"
53,631
```

## Handy args

### Service version detection scan

-- -sV

### Aggressive scan

-- -sC

### How do you access the help menu?

-h

### "quiet" mode scan

-q

### Which switch can help us to scan for a particular Range?

-r

### What switch would you use to find out RustScan's version?

-v

### Which switch will help us to select batch size?

-b

### Which switch can set timeout?

-t
